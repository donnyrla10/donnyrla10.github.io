---
title: "[프로그래머스] 모의고사(C++)"
categories: 
- CodingTest
tags:
- [Programmers, Algorithm, C++, CodingTest]
toc: true
toc_sticky: true
date: 2021-11-23
---

## 🔥 문제
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...

2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...

3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

***

## ✔️ 제한 조건

- 시험은 최대 10,000 문제로 구성되어있습니다.
- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

***

## ✔️ 입출력 예

|answers|return|
|---|---|
|[1,2,3,4,5]|[1]|
|[1,3,2,4,2]|[1,2,3]

***

## 🤔 문제 풀이

저는 문제에 규칙이 있는지 먼저 확인을 하는데요, 각 학생들이 답을 찍는 방법에는 다음과 같은 규칙이 보입니다.

1번 수포자의 경우, 1-2-3-4-5 

2번 수포자의 경우, 2-1-2-3-2-4-2-5

3번 수포자의 경우, 3-3-1-1-2-2-4-4-5-5

이렇게 숫자를 반복해서 찍는 규칙이죠!
<br>
그렇다면 각 학생의 규칙이 담긴 `배열`을 만들어서 수학 문제의 답과 비교해보는 것은 어떨까요?

1번 수포자의 벡터 a의 경우, `1-2-3-4-5`를 담고 있는데 `answers`와의 비교를 위해 반복문을 돌면서 두 벡터에 같은 인덱스로 접근했습니다. 그런데 `5(a[4])` 이후로는 어떻게 비교를 하면 좋을까요? 다시 처음으로 돌아가면 됩니다. 이를 위해 인덱스 i가 아니라 `i%5`로 하여 5(벡터 a의 사이즈)와 나눈 나머지로 접근하면 됩니다.

i = 0의 경우, 0  
i = 1의 경우, 1  
i = 2의 경우, 2
<br>...

이런 식으로 진행이 되다가 i = 5가 되면 0으로 벡터 a의 첫 원소를 가리키게 됩니다. 
수학 문제 답(`answers`)과 같다면 해당 학생의 점수를 담고 있는 벡터의 원소 값을 +1 증가시킵니다.
그 후, max 함수를 사용해 가장 큰 값을 `max_score`에 넣어주고 score를 돌면서 max값이라면 `answer`에 넣어줍니다.

***

## 👻 코드

```cpp
#include <string>
#include <vector>

using namespace std;

vector<int> a = {1, 2, 3, 4, 5};
vector<int> b = {2, 1, 2, 3, 2, 4, 2, 5};
vector<int> c = {3, 3, 1, 1, 2, 2, 4, 4, 5, 5};

vector<int> solution(vector<int> answers) {
    vector<int> answer;
    vector<int> score(3);
    int max_score = 0;
    for(int i=0; i<answers.size(); i++){
        if(answers[i] == a[i%5])    score[0]++;
        if(answers[i] == b[i%8])    score[1]++;
        if(answers[i] == c[i%10])   score[2]++;
    }
    max_score = max(max(score[0], score[1]), score[2]);
    for(int i=0; i<3; i++){
        if(max_score == score[i])
            answer.push_back(i+1);
    }
    return answer;
}
```

***

> 가장 중요 포인트!
> <br>반복되는 원소의 경우, 해당 원소로 다시 돌아갈 수 있도록 인덱스를 구현해야 한다!
> <br>반복의 끝 원소까지 가서 맨 앞 원소로 돌아와야 하므로 i%{배열 사이즈}
> <br>→ `원형 큐` ...!!


## 💡  왜 배열이 아닌 **벡터**를 사용했는가?

배열의 경우, 컴파일할 때 크기를 결정해야 합니다. 크기가 고정되어 있어야 하므로 원소 값은 변경할 수 있어도 원소를 더 추가할 수는 없습니다. 그런데 이 크기를  미리 알고 있는 것은 어렵습니다. 그래서 더욱 효율적인 활용을 위해, 배열과 같이 고정크기가 아니라 가변 크기의 자료구조를 사용하기 위해 vector를 사용합니다.

vector는 배열기반으로, 메모리상 원소들이 순차적으로 저장되어 있고 임의의 위치에 있는 원소 접근과 뒤에 원소를 추가하는 연산이 O(1)로 굉장히 빠릅니다. 그러나, 중간 삽입과 삭제 등은 굉장히 비효율적입니다. 이와 같은 연산을 위해서는 원소들을 앞으로 땡겨와야 하기 때문입니다. 

이 문제의 경우, 사실 큰 사이즈 변경이 없기 때문에 배열을 사용해도 될 것이라고 생각합니다. 그러나 좀 더 벡터에 대해 익숙해질 필요가 있다고 생각해서 이번 문제에서 사용해보았습니다.

⍩ 추후에는 벡터와 배열에 대한 포스팅을 올려보도록 하겠습니다~ ⍩
